// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package gen

import "encoding/json"
import "fmt"

type StartWorkloadRequestJson struct {
	// Arguments to be passed to the binary
	Argv []string `json:"argv"`

	// A description of the workload
	Description string `json:"description"`

	// The base64-encoded byte array of the encrypted environment with public key of
	// encryptor
	EncEnvironment SharedEncEnvJson `json:"enc_environment"`

	// The hash of the workload
	Hash string `json:"hash"`

	// The NATS configuration for the host services
	HostServiceConfig SharedHostServiceJson `json:"host_service_config"`

	// The NATS JSDomain for the workload
	Jsdomain string `json:"jsdomain"`

	// The namespace of the workload
	Namespace string `json:"namespace"`

	// The number of times the workload has been retried
	RetryCount int `json:"retry_count"`

	// The public key of the sender
	SenderPublicKey string `json:"sender_public_key"`

	// The xkey of the target node
	TargetPubXkey string `json:"target_pub_xkey"`

	// The subject that triggers the workload
	TriggerSubject string `json:"trigger_subject"`

	// The URI of the workload
	Uri string `json:"uri"`

	// The JWT for the workload
	WorkloadJwt string `json:"workload_jwt"`

	// The name of the workload
	WorkloadName string `json:"workload_name"`

	// The runtype of the workload
	WorkloadRuntype string `json:"workload_runtype"`

	// The type of the workload
	WorkloadType string `json:"workload_type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartWorkloadRequestJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["argv"]; raw != nil && !ok {
		return fmt.Errorf("field argv in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["enc_environment"]; raw != nil && !ok {
		return fmt.Errorf("field enc_environment in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["hash"]; raw != nil && !ok {
		return fmt.Errorf("field hash in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["host_service_config"]; raw != nil && !ok {
		return fmt.Errorf("field host_service_config in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["jsdomain"]; raw != nil && !ok {
		return fmt.Errorf("field jsdomain in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["namespace"]; raw != nil && !ok {
		return fmt.Errorf("field namespace in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["retry_count"]; raw != nil && !ok {
		return fmt.Errorf("field retry_count in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["sender_public_key"]; raw != nil && !ok {
		return fmt.Errorf("field sender_public_key in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["target_pub_xkey"]; raw != nil && !ok {
		return fmt.Errorf("field target_pub_xkey in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["trigger_subject"]; raw != nil && !ok {
		return fmt.Errorf("field trigger_subject in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["workload_jwt"]; raw != nil && !ok {
		return fmt.Errorf("field workload_jwt in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["workload_name"]; raw != nil && !ok {
		return fmt.Errorf("field workload_name in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["workload_runtype"]; raw != nil && !ok {
		return fmt.Errorf("field workload_runtype in StartWorkloadRequestJson: required")
	}
	if _, ok := raw["workload_type"]; raw != nil && !ok {
		return fmt.Errorf("field workload_type in StartWorkloadRequestJson: required")
	}
	type Plain StartWorkloadRequestJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StartWorkloadRequestJson(plain)
	return nil
}
